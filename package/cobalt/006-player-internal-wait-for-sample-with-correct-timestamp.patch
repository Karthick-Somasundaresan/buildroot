From 9947cb1855187e0c8c0f787855c240faa21af5b7 Mon Sep 17 00:00:00 2001
From: karol95c <292419@uwr.edu.pl>
Date: Fri, 16 Apr 2021 12:36:56 +0200
Subject: [PATCH] player_internal wait for samples with correct timestamp after
 seek

Fix for MCA macroblocks issue. Cobalt seeks for video to key frame
so to avoid dropping late frames put pipeline in PAUSED
 when late samples incoming.
---
 .../wpe/shared/player/player_internal.cc      | 57 +++++++++++++++++--
 1 file changed, 52 insertions(+), 5 deletions(-)

diff --git a/src/third_party/starboard/wpe/shared/player/player_internal.cc b/src/third_party/starboard/wpe/shared/player/player_internal.cc
index 097399cf1..07ec8be53 100644
--- a/src/third_party/starboard/wpe/shared/player/player_internal.cc
+++ b/src/third_party/starboard/wpe/shared/player/player_internal.cc
@@ -827,6 +827,7 @@ class PlayerImpl : public Player, public DrmSystemOcdm::Observer {
   mutable gint64 cached_position_ns_{0};
   mutable SbTime position_update_time_us_{0};
   PendingBounds pending_bounds_;
+  bool sample_after_key_frame_ready_{true};
 };
 
 PlayerImpl::PlayerImpl(SbPlayer player,
@@ -1407,6 +1408,37 @@ void PlayerImpl::WriteSample(SbMediaType sample_type,
                 "Adjust impl. to handle more samples after changing samples"
                 "count");
   DCHECK(number_of_sample_infos == kMaxNumberOfSamplesPerWrite);
+
+  bool check_timestamp = false;
+  {
+    ::starboard::ScopedLock lock(mutex_);
+    check_timestamp = (sample_type == kSbMediaTypeVideo) && !sample_after_key_frame_ready_;
+  }
+
+  if (check_timestamp)
+  {
+    const SbTime seek_timestamp = seek_position_ * kSbTimeNanosecondsPerMicrosecond;
+    const SbTime sample_timestamp = sample_infos[0].timestamp * kSbTimeNanosecondsPerMicrosecond;
+    const bool late_sample = seek_position_ != kSbTimeMax && (seek_timestamp > sample_timestamp);
+    if (late_sample)
+    {
+      // Request next sample to reach this one with matching timestamp to seek position
+      DispatchOnWorkerThread(new DecoderStatusTask(
+        decoder_status_func_, player_, ticket_, context_,
+        kSbPlayerDecoderStateNeedsData, MediaType::kVideo));
+
+      // Put pipeline in PAUSED if incoming samples are late in context of seek position
+      if ((GST_STATE(pipeline_) == GST_STATE_PLAYING && GST_STATE_PENDING(pipeline_) != GST_STATE_PAUSED))
+      {
+        ChangePipelineState(GST_STATE_PAUSED);
+      } 
+    }
+    else{
+      ::starboard::ScopedLock lock(mutex_);
+      sample_after_key_frame_ready_ = true;
+    }
+  }
+
   GstBuffer* buffer =
       gst_buffer_new_allocate(nullptr, sample_infos[0].buffer_size, nullptr);
   gst_buffer_fill(buffer, 0, sample_infos[0].buffer,
@@ -1429,11 +1461,17 @@ void PlayerImpl::WriteSample(SbMediaType sample_type,
   RecordTimestamp(sample_type,
                   sample_infos[0].timestamp * kSbTimeNanosecondsPerMicrosecond);
 
+  bool correct_timestamp_ready = false;
+  {
+    ::starboard::ScopedLock lock(mutex_);
+    correct_timestamp_ready = sample_after_key_frame_ready_;
+  }
+
   if (MinTimestamp(nullptr) == GST_BUFFER_TIMESTAMP(buffer) &&
       GST_STATE(pipeline_) == GST_STATE_PAUSED &&
       (GST_STATE_PENDING(pipeline_) == GST_STATE_VOID_PENDING ||
        GST_STATE_PENDING(pipeline_) == GST_STATE_PAUSED) &&
-      rate_ > .0) {
+      rate_ > .0 && correct_timestamp_ready) {
     GST_TRACE("Moving to playing for %" GST_TIME_FORMAT,
               GST_TIME_ARGS(GST_BUFFER_TIMESTAMP(buffer)));
     ChangePipelineState(GST_STATE_PLAYING);
@@ -1579,9 +1617,6 @@ void PlayerImpl::Seek(SbTime seek_to_timestamp, int ticket) {
     if (GST_STATE(pipeline_) < GST_STATE_PAUSED) {
       GST_INFO("Delaying seek.");
       if (state_ == State::kInitialPreroll) {
-        DispatchOnWorkerThread(new PlayerStatusTask(player_status_func_,
-                                                    player_, ticket_, context_,
-                                                    kSbPlayerStatePresenting));
         DispatchOnWorkerThread(new PlayerStatusTask(player_status_func_,
                                                     player_, ticket_, context_,
                                                     kSbPlayerStatePrerolling));
@@ -1597,6 +1632,10 @@ void PlayerImpl::Seek(SbTime seek_to_timestamp, int ticket) {
               kSbPlayerDecoderStateNeedsData, MediaType::kAudio));
         }
       }
+      else
+      {
+        sample_after_key_frame_ready_ = false;
+      }
       is_seek_pending_ = true;
       return;
     }
@@ -1640,7 +1679,15 @@ bool PlayerImpl::SetRate(double rate) {
   if (rate == .0) {
     ChangePipelineState(GST_STATE_PAUSED);
   } else if (rate == 1. && (current_rate == 1. || current_rate == .0)) {
-    ChangePipelineState(GST_STATE_PLAYING);
+    bool correct_timestamp_ready = true;
+    {
+      ::starboard::ScopedLock lock(mutex_);
+      correct_timestamp_ready = sample_after_key_frame_ready_;
+    }
+    if (correct_timestamp_ready)
+    {
+      ChangePipelineState(GST_STATE_PLAYING);
+    }
   } else {
     ChangePipelineState(GST_STATE_PLAYING);
     {
-- 
2.17.1

