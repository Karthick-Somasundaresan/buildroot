From f00d34305c66354d7cdcf19d2de2e03fb6971595 Mon Sep 17 00:00:00 2001
From: sebaszm <s.szczepaniak@metrological.com>
Date: Tue, 28 Jul 2020 13:32:05 +0200
Subject: [PATCH] [DisplayInfo] Nexus, use HDMI resolution instead of graphics
 resolution, limit number of notifications

---
 DisplayInfo/Nexus/PlatformImplementation.cpp | 152 +++++++++----------
 1 file changed, 74 insertions(+), 78 deletions(-)

diff --git a/DisplayInfo/Nexus/PlatformImplementation.cpp b/DisplayInfo/Nexus/PlatformImplementation.cpp
index 2df62984..82cba93c 100644
--- a/DisplayInfo/Nexus/PlatformImplementation.cpp
+++ b/DisplayInfo/Nexus/PlatformImplementation.cpp
@@ -46,7 +46,7 @@ class DisplayInfoImplementation : public Exchange::IGraphicsProperties, public E
        , _height(0)
        , _verticalFreq(0)
        , _connected(false)
-       , _hdcpprotection(HDCPProtectionType::HDCP_Unencrypted)
+       , _hdcpprotection(HDCP_Unencrypted)
        , _type(HDR_OFF)
        , _totalGpuRam(0)
        , _audioPassthrough(false)
@@ -62,11 +62,9 @@ class DisplayInfoImplementation : public Exchange::IGraphicsProperties, public E
 
         NexusHdmiOutput hdmihandle;
         if( hdmihandle ) {
-            UpdateDisplayInfoConnected(hdmihandle, _connected);
-            UpdateDisplayInfoVerticalFrequency(hdmihandle, _verticalFreq);
+            UpdateDisplayInfoConnected(hdmihandle, _connected, _width, _height, _verticalFreq, _type);
             UpdateDisplayInfoHDCP(hdmihandle, _hdcpprotection);
         }
-        UpdateDisplayInfoDisplayStatus(_width, _height, _type);
 
         UpdateAudioPassthrough(_audioPassthrough);
 
@@ -380,60 +378,58 @@ class DisplayInfoImplementation : public Exchange::IGraphicsProperties, public E
             NEXUS_HdmiOutputHandle _hdmiOutput;
     };
 
-    void UpdateDisplayInfoConnected(const NEXUS_HdmiOutputHandle& hdmiOutput, bool& connected) const
+    void UpdateDisplayInfoConnected(const NEXUS_HdmiOutputHandle& hdmiOutput,
+                                    bool& connected, uint32_t& width, uint32_t& height,
+                                    uint32_t& verticalFreq, HDRType& hdr) const
     {
         NEXUS_HdmiOutputStatus status;
         NEXUS_Error rc = NEXUS_HdmiOutput_GetStatus(hdmiOutput, &status);
         if (rc == NEXUS_SUCCESS) {
             connected = status.connected;
-        }
-    }
-
-    void UpdateDisplayInfoVerticalFrequency(const NEXUS_HdmiOutputHandle& hdmiOutput, uint32_t& verticalFreq) const
-    {
-        NEXUS_HdmiOutputStatus status;
-        NEXUS_Error rc = NEXUS_HdmiOutput_GetStatus(hdmiOutput, &status);
-        if (rc == NEXUS_SUCCESS) {
-            NEXUS_VideoFormat videoFormat = status.preferredVideoFormat;
-            NEXUS_VideoFormatInfo videoFormatInfo;
-            NEXUS_VideoFormat_GetInfo(videoFormat, &videoFormatInfo);
+            if (connected == true) {
+                NxClient_DisplaySettings displaySettings;
+                NxClient_GetDisplaySettings(&displaySettings);
 
-            // TODO: do we need vertical freq as float, or is nearest uint enough?
-            verticalFreq = videoFormatInfo.verticalFreq + 50 / 100; // vertical frequency is stored multiplied by 100
-        }
-    }
-
-    void UpdateDisplayInfoDisplayStatus(uint32_t& width, uint32_t& height, HDRType& type) const
-    {
-        NxClient_DisplaySettings displaySettings;
-        NxClient_GetDisplaySettings(&displaySettings);
 #ifdef NEXUS_HDR_SUPPORTED
-        // Read HDR status
-        switch (displaySettings.hdmiPreferences.dynamicRangeMode) {
-        case NEXUS_VideoDynamicRangeMode_eHdr10: {
-            type = HDR_10;
-            break;
-        }
-        case NEXUS_VideoDynamicRangeMode_eHdr10Plus: {
-            type = HDR_10PLUS;
-            break;
-        }
+                // Read HDR status
+                switch (displaySettings.hdmiPreferences.dynamicRangeMode) {
+                case NEXUS_VideoDynamicRangeMode_eHdr10:
+                    hdr = HDR_10;
+                    break;
+                case NEXUS_VideoDynamicRangeMode_eHdr10Plus:
+                    hdr = HDR_10PLUS;
+                    break;
+                default:
+                    hdr = HDR_OFF;
+                    break;
+                }
 #else
-        switch  (displaySettings.hdmiPreferences.drmInfoFrame.eotf) {
-        case NEXUS_VideoEotf_eHdr10: {
-            type = HDR_10;
-            break;
-        }
+                switch (displaySettings.hdmiPreferences.drmInfoFrame.eotf) {
+                case NEXUS_VideoEotf_eHdr10:
+                    hdr = HDR_10;
+                    break;
+                default:
+                    hdr = HDR_OFF;
+                    break;
+                }
 #endif
-        default:
-            break;
+
+                NEXUS_VideoFormatInfo videoFormatInfo;
+                NEXUS_VideoFormat_GetInfo(displaySettings.format, &videoFormatInfo);
+                width = videoFormatInfo.width;
+                height = videoFormatInfo.height;
+                verticalFreq = videoFormatInfo.verticalFreq;
+            } else {
+                width = 0;
+                height = 0;
+                verticalFreq = 0;
+                hdr = HDR_OFF;
+            }
         }
 
-        // Read display width and height
-        NEXUS_DisplayCapabilities capabilities;
-        NEXUS_GetDisplayCapabilities(&capabilities);
-        width = capabilities.display[0].graphics.width;
-        height = capabilities.display[0].graphics.height;
+        TRACE(Trace::Information, (_T("Display change: %s - %ix%i@%ihz, HDR:%i\n"),
+                                  (connected? _T("connected"):_T("disconnected")),
+                                  width, height, verticalFreq, hdr));
     }
 
     void UpdateDisplayInfoHDCP(const NEXUS_HdmiOutputHandle& hdmiOutput, HDCPProtectionType& hdcpprotection) const
@@ -518,7 +514,7 @@ class DisplayInfoImplementation : public Exchange::IGraphicsProperties, public E
             TRACE_L1(_T("Error in starting nexus callback thread"));
         }
     }
-    
+
     static void Callback(void *cbData, int param)
     {
         DisplayInfoImplementation* platform = static_cast<DisplayInfoImplementation*>(cbData);
@@ -532,39 +528,39 @@ class DisplayInfoImplementation : public Exchange::IGraphicsProperties, public E
 
     void UpdateDisplayInfo(const CallbackType callbacktype)
     {
-        switch ( callbacktype ) {
-        case CallbackType::HotPlug : { 
-            NexusHdmiOutput hdmihandle;
-            if( hdmihandle ) {
-                _adminLock.Lock();
-                UpdateDisplayInfoConnected(hdmihandle, _connected);
-                _adminLock.Unlock();
-            }
-            break;
-        }
-        case CallbackType::DisplaySettings : {  // DiplaySettings Changed
-            _adminLock.Lock();
-            UpdateDisplayInfoDisplayStatus(_width, _height, _type);
-            NexusHdmiOutput hdmihandle;
-            if( hdmihandle ) {
-                UpdateDisplayInfoVerticalFrequency(hdmihandle, _verticalFreq);
-            }
-            _adminLock.Unlock();
-            break;
-        }
-        case CallbackType::HDCP : {  // HDCP settings changed
-            NexusHdmiOutput hdmihandle;
-            if( hdmihandle ) {
-                _adminLock.Lock();
-                UpdateDisplayInfoHDCP(hdmihandle, _hdcpprotection);
-                _adminLock.Unlock();
+        bool notify = false;
+        bool connected = false;
+
+        _adminLock.Lock();
+        NexusHdmiOutput hdmiHandle;
+        if (hdmiHandle) {
+            switch ( callbacktype ) {
+            case CallbackType::HDCP:  // HDCP settings changed
+                if (_connected == true) {
+                    UpdateDisplayInfoHDCP(hdmiHandle, _hdcpprotection);
+                    notify = true;
+                }
+                /* fall-through! */
+            case CallbackType::HotPlug:
+            case CallbackType::DisplaySettings:
+                UpdateDisplayInfoConnected(hdmiHandle, connected, _width, _height, _verticalFreq, _type);
+                if (connected == false) {
+                    _hdcpprotection = HDCP_Unencrypted;
+                    notify = _connected; // don't bother with notifying disconnected->disconnected
+                } else {
+                    notify = true;
+                }
+                _connected = connected;
+                break;
+            default:
+                break;
             }
-            break;
         }
-        default:
-            break;
+        _adminLock.Unlock();
+
+        if (notify == true) {
+            _activity.Submit();
         }
-        _activity.Submit();
     }
 
 private:
