diff --git a/DisplayInfo/DisplayInfo.cpp b/DisplayInfo/DisplayInfo.cpp
index 6a85014..b25409e 100644
--- a/DisplayInfo/DisplayInfo.cpp
+++ b/DisplayInfo/DisplayInfo.cpp
@@ -42,6 +42,7 @@ namespace Plugin {
         if (_connectionProperties != nullptr) {
 
             _graphicsProperties = _connectionProperties->QueryInterface<Exchange::IGraphicsProperties>();
+            _hdrProperties = _connectionProperties->QueryInterface<Exchange::IHDRProperties>();
             if (_graphicsProperties == nullptr) {
 
                 _connectionProperties->Release();
@@ -76,6 +77,10 @@ namespace Plugin {
             _connectionProperties = nullptr;
         }
 
+        if (_hdrProperties != nullptr) {
+            _hdrProperties->Release();
+            _hdrProperties = nullptr;
+        }
         _connectionId = 0;
     }
 
@@ -122,16 +127,42 @@ namespace Plugin {
 
     void DisplayInfo::Info(JsonData::DisplayInfo::DisplayinfoData& displayInfo) const
     {
-        displayInfo.Totalgpuram = _graphicsProperties->TotalGpuRam();
-        displayInfo.Freegpuram = _graphicsProperties->FreeGpuRam();
-
-        displayInfo.Audiopassthrough = _connectionProperties->IsAudioPassthrough();
-        displayInfo.Connected = _connectionProperties->Connected();
-        displayInfo.Width = _connectionProperties->Width();
-        displayInfo.Height = _connectionProperties->Height();
-        displayInfo.Atmossupported = _connectionProperties->IsAtmosSupported();
-        displayInfo.Hdcpprotection = static_cast<JsonData::DisplayInfo::DisplayinfoData::HdcpprotectionType>(_connectionProperties->HDCPProtection());
-        displayInfo.Hdrtype = static_cast<JsonData::DisplayInfo::DisplayinfoData::HdrtypeType>(_connectionProperties->Type());
+        bool boolean;
+        uint32_t value;
+        uint64_t value64;
+        Exchange::IHDRProperties::HDRType hdrType;
+        Exchange::IConnectionProperties::HDCPProtectionType hdcpType;
+
+        if (_graphicsProperties->TotalGpuRam(value64) == Core::ERROR_NONE) {
+            displayInfo.Totalgpuram = value64;
+        }
+
+        if (_graphicsProperties->FreeGpuRam(value64) == Core::ERROR_NONE) {
+            displayInfo.Freegpuram = value64;
+        }
+
+        if (_connectionProperties->IsAtmosSupported(boolean) == Core::ERROR_NONE) {
+            displayInfo.Atmossupported = boolean;
+        }
+
+        if (_connectionProperties->IsAudioPassthrough(boolean) == Core::ERROR_NONE) {
+            displayInfo.Audiopassthrough = boolean;
+        }
+        if (_connectionProperties->Connected(boolean) == Core::ERROR_NONE) {
+            displayInfo.Connected = boolean;
+        }
+        if (_connectionProperties->Width(value) == Core::ERROR_NONE) {
+            displayInfo.Width = value;
+        }
+        if (_connectionProperties->Height(value) == Core::ERROR_NONE) {
+            displayInfo.Height = value;
+        }
+        if (static_cast<const Exchange::IConnectionProperties*>(_connectionProperties)->HDCPProtection(hdcpType) == Core::ERROR_NONE) {
+            displayInfo.Hdcpprotection = static_cast<JsonData::DisplayInfo::DisplayinfoData::HdcpprotectionType>(hdcpType);
+        }
+        if ((_hdrProperties != nullptr) && (_hdrProperties->HDRSetting(hdrType) == Core::ERROR_NONE)) {
+            displayInfo.Hdrtype = static_cast<JsonData::DisplayInfo::DisplayinfoData::HdrtypeType>(hdrType);
+        }
     }
 
 } // namespace Plugin
diff --git a/DisplayInfo/DisplayInfo.h b/DisplayInfo/DisplayInfo.h
index ea2b57d..b5a60a6 100644
--- a/DisplayInfo/DisplayInfo.h
+++ b/DisplayInfo/DisplayInfo.h
@@ -60,9 +60,9 @@ namespace Plugin {
                     _client = nullptr;
                 }
             }
-            void Updated() override
+            void Updated(const Exchange::IConnectionProperties::INotification::Source event) override
             {
-                _parent.Updated();
+                _parent.Updated(event);
             }
             BEGIN_INTERFACE_MAP(Notification)
             INTERFACE_ENTRY(Exchange::IConnectionProperties::INotification)
@@ -82,6 +82,7 @@ namespace Plugin {
             , _connectionId(0)
             , _graphicsProperties(nullptr)
             , _connectionProperties(nullptr)
+            , _hdrProperties(nullptr)
             , _notification(this)
         {
             RegisterAll();
@@ -97,6 +98,7 @@ namespace Plugin {
         INTERFACE_ENTRY(PluginHost::IWeb)
         INTERFACE_AGGREGATE(Exchange::IGraphicsProperties, _graphicsProperties)
         INTERFACE_AGGREGATE(Exchange::IConnectionProperties, _connectionProperties)
+        INTERFACE_AGGREGATE(Exchange::IHDRProperties, _hdrProperties)
         INTERFACE_ENTRY(PluginHost::IDispatcher)
         END_INTERFACE_MAP
 
@@ -112,7 +114,7 @@ namespace Plugin {
         virtual void Inbound(Web::Request& request) override;
         virtual Core::ProxyType<Web::Response> Process(const Web::Request& request) override;
 
-        void Updated()
+        void Updated(const Exchange::IConnectionProperties::INotification::Source /* event */)
         {
             event_updated();
         }
@@ -131,6 +133,7 @@ namespace Plugin {
         uint32_t _connectionId;
         Exchange::IGraphicsProperties* _graphicsProperties;
         Exchange::IConnectionProperties* _connectionProperties;
+        Exchange::IHDRProperties* _hdrProperties;
         Core::Sink<Notification> _notification;
     };
 
diff --git a/DisplayInfo/DisplayInfo.json b/DisplayInfo/DisplayInfo.json
new file mode 100644
index 0000000..8b9b746
--- /dev/null
+++ b/DisplayInfo/DisplayInfo.json
@@ -0,0 +1,13 @@
+{
+ "locator":"libWPEFrameworkDisplayInfo.so",
+ "classname":"DisplayInfo",
+ "precondition":[
+  "Platform"
+ ],
+ "autostart":true,
+ "configuration":{
+  "root":{
+   "mode":"Off"
+  }
+ }
+}
\ No newline at end of file
diff --git a/DisplayInfo/DisplayInfoTracing.h b/DisplayInfo/DisplayInfoTracing.h
index 0c15d7d..763be84 100644
--- a/DisplayInfo/DisplayInfoTracing.h
+++ b/DisplayInfo/DisplayInfoTracing.h
@@ -24,7 +24,7 @@
 namespace WPEFramework {
 namespace Plugin {
 
-    class EXTERNAL HDCPDetailedInfo {
+    class HDCPDetailedInfo {
     public:
         // -------------------------------------------------------------------
         // This object should not be copied or assigned. Prevent the copy
diff --git a/DisplayInfo/ExtendedDisplayIdentification.h b/DisplayInfo/ExtendedDisplayIdentification.h
new file mode 100644
index 0000000..629ec0b
--- /dev/null
+++ b/DisplayInfo/ExtendedDisplayIdentification.h
@@ -0,0 +1,320 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once 
+#include "Module.h"
+
+namespace WPEFramework {
+namespace Plugin {
+
+    class ExtendedDisplayIdentification {
+    public:
+        enum Type {
+            Undefined = 0,
+            HDMIa = 2,
+            HDMIb = 3,
+            MDDI = 4,
+            DisplayPort = 5
+        };
+
+        class Buffer {
+        private:
+            static constexpr uint16_t edid_block_size = 128;
+        public:
+            Buffer() {
+            }
+            Buffer(const Buffer& copy) {
+                ::memcpy(_data, copy._data, sizeof(_data));
+            }
+            ~Buffer() = default;
+
+            Buffer& operator= (const Buffer& copy) = delete;
+
+        public:
+            uint16_t Length() const {
+                return (edid_block_size);
+            }
+            operator uint8_t* () {
+                return (_data);
+            }
+            operator const uint8_t* () const {
+                return (_data);
+            }
+
+        private:
+            uint8_t _data[edid_block_size];
+        };
+
+        using BufferList = std::list<Buffer>;
+
+        class Iterator {
+        public:
+            Iterator() 
+                : _segments(nullptr)
+                , _index()
+                , _reset(true) {
+            }
+            Iterator(const BufferList& rhs) 
+                : _segments(&rhs)
+                , _index(rhs.begin())
+                , _reset(true) {
+            }
+            Iterator(const Iterator& copy) 
+                : _segments(copy._segments)
+                , _index()
+                , _reset(true) {
+                if (_segments != nullptr) {
+                    _index = _segments->cbegin();
+                }
+            }
+            ~Iterator() = default;
+
+            Iterator& operator= (const Iterator& rhs) {
+                
+                return (*this);
+            }
+
+        public:
+            bool IsValid() const {
+                return ((_reset == false) && (_segments != nullptr) && (_index != _segments->cend()));
+            }
+            void Reset() {
+                _reset = true;
+                if (_segments != nullptr) {
+                    _index = _segments->cbegin();
+                }
+            }
+            bool Next() {
+                if (_reset == true) {
+                    _reset = false;
+                }
+                else if ((_segments != nullptr) && (_index != _segments->cend())) {
+                    _index++;
+                }
+                return ((_segments != nullptr) && (_index != _segments->cend()));
+            }
+            uint8_t Type() const {
+                return (IsValid() ? (*_index)[0] : 0xFF);
+            }
+            const Buffer& Current() const {
+                ASSERT(IsValid() == true);
+                return (*_index);
+            }
+ 
+        private:
+            const BufferList* _segments;
+            BufferList::const_iterator _index;
+            bool _reset;
+        };
+
+        class CEA {
+        public:
+            CEA() = delete;    
+            CEA(const CEA&) = delete;    
+            CEA& operator= (const CEA&) = delete;    
+            
+            CEA(const Buffer& data) 
+                : _segment(data) {
+                ASSERT(_segment[0] == 0x02);
+            }
+            ~CEA() {
+            }
+
+        public:
+            uint8_t Version() const {
+                return (_segment[1]);
+            }
+
+        private:
+            Buffer _segment;
+        };
+
+
+    public:
+        ExtendedDisplayIdentification (const ExtendedDisplayIdentification&) = delete;
+        ExtendedDisplayIdentification& operator= (const ExtendedDisplayIdentification&) = delete;
+
+        ExtendedDisplayIdentification()
+            : _segments() {
+            // It is already invalid if the first byte != 0x00
+            _base[0] = 0x55;
+        }
+        ~ExtendedDisplayIdentification() {
+        }
+
+    public:
+        // -------------------------------------------------------------
+        // Only use the accessors if this method return true!!!
+        // -------------------------------------------------------------
+        inline bool IsValid() const {
+            return ( (_base[0] == 0x00) && 
+                     (_base[1] == 0xFF) &&
+                     (_base[2] == 0xFF) &&
+                     (_base[3] == 0xFF) &&
+                     (_base[4] == 0xFF) &&
+                     (_base[5] == 0xFF) &&
+                     (_base[6] == 0xFF) &&
+                     (_base[7] == 0x00) );
+        }
+
+        uint16_t Raw(const uint16_t length, uint8_t data[]) const {
+            uint16_t written = 0;
+
+            // We always have a base if it is valid...
+            if (IsValid() == true) {
+                uint16_t segment = std::min(Length(), length);
+                BufferList::const_iterator index(_segments.cbegin());
+
+                // By definition, we can copy the base...
+                ::memcpy(data, _base, segment);
+                written = segment;
+                
+                while ( (written < length) && (index != _segments.cend()) ) {
+                    segment = std::min(Length(), static_cast<uint16_t>(length - written));
+                    ::memcpy(&(data[written]), *index, segment);
+                    index++;
+                    written += segment;
+                }
+            }
+
+            return (written);
+        }
+
+        // -------------------------------------------------------------
+        // Accessors to the base information of the EDID raw buffer.
+        // -------------------------------------------------------------
+        string Manufacturer() const {
+            string result;
+            if (IsValid() == true) {
+                uint16_t value = ((_base[0x08] << 8) | (_base[0x09]));
+                result  = ManufactereChar(value >> 10);
+                result += ManufactereChar(value >> 5);
+                result += ManufactereChar(value);
+            }
+            return (result);
+        }
+        uint16_t ProductCode() const {
+            uint16_t result = ~0;
+ 
+            if (IsValid() == true) {
+                result = _base[0x0B] << 8 |
+                         _base[0x0A];
+            }
+            return (result);
+        }
+        uint32_t Serial() const {
+            uint32_t result = ~0;
+            if (IsValid() == true) {
+                result = _base[0x0F] << 24 |
+                         _base[0x0E] << 16 |
+                         _base[0x0D] << 8  |
+                         _base[0x0C];
+            }
+            return (result);
+        }
+        // If the Week = 0xFF, it means the year is the year when this model was 
+        // release. If 0 <= week <= 53 the year represnt the year when the device
+        // was manufactured.
+        uint8_t Week() const {
+            return (IsValid() ? _base[0x10] : 0x00);
+        }
+        uint16_t Year() const {
+            return (IsValid() ? 1990 + _base[0x11] : 0x00);
+        }
+        uint8_t Major() const {
+            return (IsValid() ? _base[0x12] : 0x00);
+        }
+        uint8_t Minor() const {
+            return (IsValid() ? _base[0x13] : 0x00);
+        }
+
+        bool Digital() const {
+            return ((_base[14] & 0x80) != 0);
+        }
+        uint8_t BitsPerColor() const {
+            static uint8_t bitsPerColor[] = { 0, 6, 8, 10, 12, 14, 16, 255 };
+            return (bitsPerColor[(_base[0x14] >> 4) & 0x7]);
+        }
+        Type VideoInterface() const {
+            return (static_cast<Type> (_base[0x14] & 0x0F));
+        }
+
+        Iterator Extensions() const {
+            return (Iterator(_segments));
+        }
+
+        // -------------------------------------------------------------
+        // Operators to get access to the EDID strorage raw information.
+        // -------------------------------------------------------------
+        uint16_t Length () const {
+            return (_base.Length());
+        }
+        uint8_t Segments() const {
+            return (IsValid() ? _base[0x7e] + 1 : 1);
+        }
+        uint8_t* Segment(const uint8_t index) {
+            uint8_t* result = nullptr;
+
+            ASSERT (index <= Segments());
+
+            if (index == 0) {
+                result = _base.operator uint8_t* ();
+            }
+            else if (index <= Segments()) {
+                BufferList::iterator pointer = _segments.begin();
+                uint8_t current = 1;
+                while (current <= index) { 
+                    if (pointer != _segments.end()) {
+                        pointer++;
+                    }
+                    else {
+                        _segments.emplace_back();
+                    }
+                    current++;
+                }
+                result = (pointer != _segments.end() ? pointer->operator uint8_t*() : _segments.back().operator uint8_t* ());
+            }
+
+            return (result);
+        }
+
+        uint8_t WidthInCentimeters() const {
+            return IsValid() ? _base[21] : 0;
+        }
+
+        uint8_t HeightInCentimeters() const {
+            return IsValid() ? _base[22] : 0;
+        }
+
+        void Clear() {
+            _base[0] = 0x55;
+            _segments.clear();
+        }
+
+    private:
+        inline TCHAR ManufactereChar(uint8_t value) const {
+            return static_cast<TCHAR>('A' + ((value - 1) & 0x1F));
+        }
+        
+    private:
+        Buffer _base;
+        BufferList _segments;
+    };
+}
+}
diff --git a/DisplayInfo/Nexus/PlatformImplementation.cpp b/DisplayInfo/Nexus/PlatformImplementation.cpp
index 6f4b825..5e4111a 100644
--- a/DisplayInfo/Nexus/PlatformImplementation.cpp
+++ b/DisplayInfo/Nexus/PlatformImplementation.cpp
@@ -18,8 +18,10 @@
  */
  
 #include "../Module.h"
-#include <interfaces/IDisplayInfo.h>
 #include "../DisplayInfoTracing.h"
+#include "../ExtendedDisplayIdentification.h"
+
+#include <interfaces/IDisplayInfo.h>
 
 #include <nexus_config.h>
 #include <nexus_platform.h>
@@ -32,6 +34,7 @@
     )
 
 #define NEXUS_HDCPVERSION_SUPPORTED
+#define NEXUS_HDR_SUPPORTED
 
 #endif
 
@@ -39,7 +42,10 @@
 namespace WPEFramework {
 namespace Plugin {
 
-class DisplayInfoImplementation : public Exchange::IGraphicsProperties, public Exchange::IConnectionProperties {
+class DisplayInfoImplementation : 
+    public Exchange::IGraphicsProperties, 
+    public Exchange::IConnectionProperties,
+    public Exchange::IHDRProperties  {
 public:
     DisplayInfoImplementation()
        : _width(0)
@@ -51,6 +57,7 @@ public:
        , _totalGpuRam(0)
        , _audioPassthrough(false)
        , _atmosSupport(false)
+       , _EDID()
        , _adminLock()
        , _activity(*this) {
 
@@ -65,6 +72,7 @@ public:
         if( hdmihandle ) {
             UpdateDisplayInfoConnected(hdmihandle, _connected, _width, _height, _verticalFreq, _type, _atmosSupport);
             UpdateDisplayInfoHDCP(hdmihandle, _hdcpprotection);
+            RetrieveEDID(hdmihandle, _EDID);
         }
 
         UpdateAudioPassthrough(_audioPassthrough);
@@ -82,11 +90,12 @@ public:
 
 public:
     // Graphics Properties interface
-    uint64_t TotalGpuRam() const override
+    uint32_t TotalGpuRam(uint64_t& total) const override
     {
-        return _totalGpuRam;
+        total = _totalGpuRam;
+        return Core::ERROR_NONE;
     }
-    uint64_t FreeGpuRam() const override
+    uint32_t FreeGpuRam(uint64_t& free) const override
     {
         uint64_t freeRam = 0;
         NEXUS_MemoryStatus status;
@@ -116,7 +125,8 @@ public:
             }
         }
 #endif
-        return (freeRam);
+        free = (freeRam);
+        return rc == NEXUS_SUCCESS ? Core::ERROR_NONE : Core::ERROR_GENERAL;
     }
 
     // Connection Properties interface
@@ -153,36 +163,74 @@ public:
         return (Core::ERROR_NONE);
     }
 
-    bool IsAudioPassthrough () const override
+    uint32_t IsAudioPassthrough (bool& value) const override
     {
-        return _audioPassthrough;
+        value = _audioPassthrough;
+        return (Core::ERROR_NONE);
     }
-    bool Connected() const override
+    uint32_t Connected(bool& connected) const override
     {
-        return _connected;
+        connected = _connected;
+        return (Core::ERROR_NONE);
     } 
-    uint32_t Width() const override
+    uint32_t Width(uint32_t& value) const override
     {
-        return _width;
+        value = _width;
+        return (Core::ERROR_NONE);
     }
-    uint32_t Height() const override
+    uint32_t Height(uint32_t& value) const override
     {
-        return _height;
+        value = _height;
+        return (Core::ERROR_NONE);
     }
-    uint32_t VerticalFreq() const override
+    uint32_t VerticalFreq(uint32_t& value) const override
     {
-        return _verticalFreq;
+        value = _verticalFreq;
+        return (Core::ERROR_NONE);
     }
-    HDRType Type() const override
+    uint32_t IsAtmosSupported(bool& supported) const override
     {
-        return _type;
+        supported = _atmosSupport;
+        return (Core::ERROR_NONE);
+    }
+    uint32_t HDCPProtection(HDCPProtectionType& value) const override {
+        value = _hdcpprotection;
+        return (Core::ERROR_NONE);
+    }
+    uint32_t HDCPProtection(const HDCPProtectionType /* value */) override {
+        return (Core::ERROR_GENERAL);
     }
-    bool IsAtmosSupported() const override {
-        return _atmosSupport;
+    uint32_t EDID (uint16_t& length /* @inout */, uint8_t data[] /* @out @length:length */) const override {
+        length = _EDID.Raw(length, data);
+        return length ? (Core::ERROR_NONE) : Core::ERROR_UNAVAILABLE;
     }
-    HDCPProtectionType HDCPProtection() const override {
-        return _hdcpprotection;
+    uint32_t WidthInCentimeters(uint8_t& width) const override {
+        width = _EDID.WidthInCentimeters();
+        return width ? (Core::ERROR_NONE) : Core::ERROR_UNAVAILABLE;
+    }
+    uint32_t HeightInCentimeters(uint8_t& height) const override {
+        height = _EDID.HeightInCentimeters();
+        return height ? (Core::ERROR_NONE) : Core::ERROR_UNAVAILABLE;
+    }
+    uint32_t PortName (string& name /* @out */) const {
+        name = "HDMI" + Core::NumberType<uint8_t>(0).Text();
+        return (Core::ERROR_NONE);
+    }
+
+    uint32_t TVCapabilities(IHDRIterator*& type) const override
+    {
+        return (Core::ERROR_UNAVAILABLE);
+    }
+    uint32_t STBCapabilities(IHDRIterator*& type) const override
+    {
+        return (Core::ERROR_UNAVAILABLE);
+    }
+    uint32_t HDRSetting(HDRType& type) const override
+    {
+        type = _type;
+        return (Core::ERROR_NONE);
     }
+
     void Dispatch() const
     {
         _adminLock.Lock();
@@ -190,7 +238,7 @@ public:
         std::list<IConnectionProperties::INotification*>::const_iterator index = _observers.begin();
 
         while(index != _observers.end()) {
-            (*index)->Updated();
+            (*index)->Updated(IConnectionProperties::INotification::Source::HDCP_CHANGE);
             index++;
         }
 
@@ -200,6 +248,7 @@ public:
     BEGIN_INTERFACE_MAP(DisplayInfoImplementation)
         INTERFACE_ENTRY(Exchange::IGraphicsProperties)
         INTERFACE_ENTRY(Exchange::IConnectionProperties)
+        INTERFACE_ENTRY(Exchange::IHDRProperties)
     END_INTERFACE_MAP
 
 private:
@@ -351,13 +400,13 @@ private:
 #endif
 
     class NexusHdmiOutput {
-        public:
+    public:
         NexusHdmiOutput(const NexusHdmiOutput&) = delete;
         NexusHdmiOutput& operator=(const NexusHdmiOutput&) = delete;
 
-        NexusHdmiOutput() : _hdmiOutput(nullptr) {
+        NexusHdmiOutput(const uint8_t hdmiPort = 0) : _hdmiOutput(nullptr) {
 
-            _hdmiOutput = NEXUS_HdmiOutput_Open(NEXUS_ALIAS_ID + 0, NULL);
+            _hdmiOutput = NEXUS_HdmiOutput_Open(NEXUS_ALIAS_ID + hdmiPort, NULL);
 
             if( _hdmiOutput == nullptr ) {
                 TRACE(Trace::Error, (_T("Error opening Nexus HDMI ouput")));
@@ -393,29 +442,31 @@ private:
             if (connected == true) {
                 NxClient_DisplaySettings displaySettings;
                 NxClient_GetDisplaySettings(&displaySettings);
-
 #if ((NEXUS_PLATFORM_VERSION_MAJOR >= 19) && (NEXUS_PLATFORM_VERSION_MINOR >= 2))
                 NEXUS_HdmiOutputEdidRxDolbyAudioCodecDependent edidDataDolby;
                 NEXUS_HdmiOutput_GetDbCodecDependentEdidData(hdmiOutput, &edidDataDolby);
                 isAtmosSupported = edidDataDolby.ddpAtmosSupported;
 #endif
 
-#if ((NEXUS_PLATFORM_VERSION_MAJOR >= 19) && (NEXUS_PLATFORM_VERSION_MINOR >= 2))
-                NEXUS_HdmiOutputEdidData edidData;
-                NEXUS_Error edidRc = NEXUS_HdmiOutput_GetEdidData(hdmiOutput, &edidData);
-                if(edidRc != NEXUS_SUCCESS){
-                    TRACE_L1(_T("Failed to get edidData with rc=%d", edidRc));
+
+                NxClient_DisplayStatus status;
+                NEXUS_Error rcStatus = NxClient_GetDisplayStatus(&status);
+                if(rcStatus != NEXUS_SUCCESS){
+                    TRACE_L1(_T("Failed to get display status with rc=%d", rcStatus));
                 }
-                if(edidData.hdrdb.valid == true) {
-                    if((edidData.hdrdb.eotfSupported[NEXUS_VideoEotf_eHdr10] == true) || (edidData.hdrdb.eotfSupported[NEXUS_VideoEotf_ePq] == true)){
-                        hdr = HDR_10;
-                    } else if(edidData.hdrdb.eotfSupported[NEXUS_VideoEotf_eHlg] == true) {
-                        hdr = HDR_HLG;
-                    } else {
-                        hdr = HDR_OFF;
-                    }
-                } else {
-                    TRACE_L1(_T("Failed to get edid hdr db"));
+
+#ifdef NEXUS_HDR_SUPPORTED
+                // Read HDR status
+                switch (status.hdmi.dynamicRangeMode) {
+                case NEXUS_VideoDynamicRangeMode_eHdr10:
+                    hdr = HDR_10;
+                    break;
+                case NEXUS_VideoDynamicRangeMode_eHdr10Plus:
+                    hdr = HDR_10PLUS;
+                    break;
+                default:
+                    hdr = HDR_OFF;
+                    break;
                 }
 #else
                 switch (displaySettings.hdmiPreferences.drmInfoFrame.eotf) {
@@ -570,6 +621,11 @@ private:
             default:
                 break;
             }
+            if (connected == true) {
+                RetrieveEDID(hdmiHandle, _EDID);
+            } else {
+                _EDID.Clear();
+            }
         }
         _adminLock.Unlock();
 
@@ -578,6 +634,30 @@ private:
         }
     }
 
+    // rc = BHDM_EDID_GetHdrStaticMetadatadb(hdmiOutput->hdmHandle, &_hdrdb);
+    void RetrieveEDID(NEXUS_HdmiOutputHandle handle, ExtendedDisplayIdentification& info) {
+        // typedef struct NEXUS_HdmiOutputEdidBlock
+        // {
+        //     uint8_t data[128];
+        // } NEXUS_HdmiOutputEdidBlock;
+
+        // NEXUS_Error NEXUS_HdmiOutput_GetEdidBlock(
+        //      NEXUS_HdmiOutputHandle output,
+        //      unsigned blockNum,
+        //      NEXUS_HdmiOutputEdidBlock *pBlock    /* [out] Block of raw EDID data */
+        //      );
+        NEXUS_Error error;
+        uint8_t index = 0;
+
+        do {
+            error = NEXUS_HdmiOutput_GetEdidBlock(handle, index, reinterpret_cast<NEXUS_HdmiOutputEdidBlock*>(info.Segment(index)));
+
+            index++;
+
+        } while ( (index <= info.Segments()) && (error == 0) );
+    }
+
+
 private:
     uint32_t _width;
     uint32_t _height;
@@ -594,6 +674,7 @@ private:
     std::list<IConnectionProperties::INotification*> _observers;
 
     NEXUS_PlatformConfiguration _platformConfig;
+    ExtendedDisplayIdentification _EDID;
 
     mutable Core::CriticalSection _adminLock;
 
diff --git a/DisplayInfo/RPI/PlatformImplementation.cpp b/DisplayInfo/RPI/PlatformImplementation.cpp
index d565922..88c494b 100644
--- a/DisplayInfo/RPI/PlatformImplementation.cpp
+++ b/DisplayInfo/RPI/PlatformImplementation.cpp
@@ -18,6 +18,8 @@
  */
  
 #include "../Module.h"
+#include "../ExtendedDisplayIdentification.h"
+
 #include <interfaces/IDisplayInfo.h>
 
 #include <bcm_host.h>
@@ -27,14 +29,17 @@ namespace WPEFramework {
 namespace Plugin {
 
 class DisplayInfoImplementation : public Exchange::IGraphicsProperties, public Exchange::IConnectionProperties {
-
 public:
+    DisplayInfoImplementation(const DisplayInfoImplementation&) = delete;
+    DisplayInfoImplementation& operator= (const DisplayInfoImplementation&) = delete;
+
     DisplayInfoImplementation()
         : _width(0)
         , _height(0)
         , _connected(false)
         , _totalGpuRam(0)
         , _audioPassthrough(false)
+        , _EDID()
         , _adminLock()
         , _activity(*this) {
 
@@ -46,9 +51,6 @@ public:
 
         vc_tv_register_callback(&DisplayCallback, reinterpret_cast<void*>(this));
     }
-
-    DisplayInfoImplementation(const DisplayInfoImplementation&) = delete;
-    DisplayInfoImplementation& operator= (const DisplayInfoImplementation&) = delete;
     virtual ~DisplayInfoImplementation()
     {
         bcm_host_deinit();
@@ -56,15 +58,15 @@ public:
 
 public:
     // Graphics Properties interface
-    uint64_t TotalGpuRam() const override
+    uint32_t TotalGpuRam(uint64_t& total) const override
     {
-        return _totalGpuRam;
+        total = _totalGpuRam;
+        return (Core::ERROR_NONE);
     }
-    uint64_t FreeGpuRam() const override
+    uint32_t FreeGpuRam(uint64_t& free) const override
     {
-        uint64_t result;
-        Command("get_mem reloc ", result);
-        return (result);
+        Command("get_mem reloc ", free);
+        return (Core::ERROR_NONE);
     }
 
     // Connection Properties interface
@@ -100,38 +102,76 @@ public:
 
         return (Core::ERROR_NONE);
     }
-    bool IsAudioPassthrough () const override
+    uint32_t IsAudioPassthrough (bool& value) const override
     {
-        return _audioPassthrough;
+        value = _audioPassthrough;
+        return (Core::ERROR_NONE);
     }
-    bool Connected() const override
+    uint32_t Connected(bool& connected) const override
     {
-        return _connected;
+        connected = _connected;
+        return (Core::ERROR_NONE);
     }
-    uint32_t Width() const override
+    uint32_t Width(uint32_t& value) const override
     {
-        return _width;
+        value = _width;
+        return (Core::ERROR_NONE);
     }
-    uint32_t Height() const override
+    uint32_t Height(uint32_t& value) const override
     {
-        return _height;
+        value = _height;
+        return (Core::ERROR_NONE);
     }
-    uint32_t VerticalFreq() const override
+    uint32_t VerticalFreq(uint32_t& value) const override
     {
-        return ~0;
+        value = 0;
+        return (Core::ERROR_NONE);
     }
     // Atmos on RPI is not used
-    bool IsAtmosSupported() const override {
-        return false;
+    uint32_t IsAtmosSupported(bool& supported) const override
+    {
+        supported = false;
+        return (Core::ERROR_NONE);
     }
     // HDCP support is not used for RPI now, it is always settings as DISPMANX_PROTECTION_NONE
-    HDCPProtectionType HDCPProtection() const override {
-        return HDCPProtectionType::HDCP_Unencrypted;
+    uint32_t HDCPProtection(HDCPProtectionType& value) const override {
+        value = HDCPProtectionType::HDCP_Unencrypted;
+        return (Core::ERROR_NONE);
+    }
+    uint32_t HDCPProtection (const HDCPProtectionType /* value */) override {
+        return (Core::ERROR_GENERAL);
+    }
+    uint32_t EDID (uint16_t& length /* @inout */, uint8_t data[] /* @out @length:length */) const override {
+        length = _EDID.Raw(length, data);
+        return (Core::ERROR_NONE);
+    }
+    uint32_t WidthInCentimeters(uint8_t& width) const override {
+        width = _EDID.WidthInCentimeters();
+        return width ? (Core::ERROR_NONE) : Core::ERROR_UNAVAILABLE;
+    }
+    uint32_t HeightInCentimeters(uint8_t& height) const override {
+        height = _EDID.WidthInCentimeters();
+        return height ? (Core::ERROR_NONE) : Core::ERROR_UNAVAILABLE;
     }
-    HDRType Type() const override
+
+    uint32_t PortName (string& name /* @out */) const {
+        name =_T("HDMI") + Core::NumberType<uint8_t>(0).Text();
+        return (Core::ERROR_NONE);
+    }
+    uint32_t TVCapabilities(IHDRIterator*& type) const override
     {
-        return HDR_OFF;
+        return (Core::ERROR_UNAVAILABLE);
     }
+    uint32_t STBCapabilities(IHDRIterator*& type) const override
+    {
+        return (Core::ERROR_UNAVAILABLE);
+    }
+    uint32_t HDRSetting(HDRType& type) const override
+    {
+        type = HDR_OFF;
+        return (Core::ERROR_NONE);
+    }
+
     void Dispatch()
     {
         TV_DISPLAY_STATE_T tvState;
@@ -156,10 +196,21 @@ public:
 
         _adminLock.Lock();
 
+        if (_connected == true) {
+            TRACE(Trace::Information, (_T("HDCP connected: [%d,%d]"), _width, _height));
+            
+            RetrieveEDID(_EDID, -1);
+        }
+        else {
+            _EDID.Clear();
+            TRACE(Trace::Information, (_T("HDCP disconnected")));
+        }
+
+
         std::list<IConnectionProperties::INotification*>::const_iterator index = _observers.begin();
 
         if (index != _observers.end()) {
-            (*index)->Updated();
+            (*index)->Updated(Exchange::IConnectionProperties::INotification::Source::HDCP_CHANGE);
         }
 
         _adminLock.Unlock();
@@ -259,12 +310,35 @@ private:
         }
     }
 
+    void RetrieveEDID(ExtendedDisplayIdentification& info, int displayId = -1) {
+        int size;
+        uint8_t  index = 0;
+
+        do {
+            if (displayId != -1) {
+                #ifdef RPI4 // or higer
+                size = vc_tv_hdmi_ddc_read_id(displayId, index * info.Length(), info.Length(), info.Segment(index));
+                #endif
+            }
+            else {
+                uint8_t* buffer = info.Segment(index);
+                size = vc_tv_hdmi_ddc_read(index * info.Length(), info.Length(), buffer);
+            }
+
+            index++;
+
+        } while ( (index < info.Segments()) && (size == info.Length()) );
+
+        TRACE(Trace::Information, (_T("EDID, Read %d segments [%d]"), index, size));
+    } 
+
 private:
     uint32_t _width;
     uint32_t _height;
     bool _connected;
     uint64_t _totalGpuRam;
     bool _audioPassthrough;
+    ExtendedDisplayIdentification _EDID;
 
     std::list<IConnectionProperties::INotification*> _observers;
 
