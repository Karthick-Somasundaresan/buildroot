diff --git a/Source/com/IRPCIterator.h b/Source/com/IRPCIterator.h
index 3d03d5e7..2d665dde 100644
--- a/Source/com/IRPCIterator.h
+++ b/Source/com/IRPCIterator.h
@@ -18,16 +18,13 @@
  */
 
 #pragma once
-
-// ---- Include system wide include files ----
-
-// ---- Include local include files ----
-#include "Module.h"
+#include <core/core.h>
 
 namespace WPEFramework {
 
 namespace RPC {
 
+    // @iterator
     template<typename ELEMENT, const uint32_t INTERFACE_ID>
     struct IIteratorType : virtual public Core::IUnknown {
 
diff --git a/Source/displayinfo/DisplayInfo.cpp b/Source/displayinfo/DisplayInfo.cpp
index 14a5c167..4bbd5d27 100644
--- a/Source/displayinfo/DisplayInfo.cpp
+++ b/Source/displayinfo/DisplayInfo.cpp
@@ -51,9 +51,9 @@ private:
         {
         }
 
-        void Updated() override
+        void Updated(const Exchange::IConnectionProperties::INotification::Source event) override
         {
-            _parent.Updated();
+            _parent.Updated(event);
         }
 
         BEGIN_INTERFACE_MAP(Notification)
@@ -71,9 +71,12 @@ private:
         : _refCount(1)
         , _name(displayName)
         , _displayConnection(interface)
+        , _hdrProperties(interface != nullptr ? interface->QueryInterface<Exchange::IHDRProperties>() : nullptr)
         , _notification(this)
         , _callbacks()
     {
+        ASSERT (_displayConnection != nullptr);
+        _displayConnection->AddRef();
         _displayConnection->Register(&_notification);
     }
 
@@ -122,6 +125,7 @@ private:
                 if (displayInterface != nullptr) {
                     result = new DisplayInfo(name, displayInterface);
                     std::list<DisplayInfo*>::emplace_back(result);
+                    displayInterface->Release();
                 }
             }
             _adminLock.Unlock();
@@ -258,7 +262,13 @@ private:
 
     ~DisplayInfo()
     {
-        _displayConnection->Unregister(&_notification);
+        if (_displayConnection != nullptr) {
+            _displayConnection->Unregister(&_notification);
+            _displayConnection->Release();
+        }
+        if (_hdrProperties != nullptr) {
+            _hdrProperties->Release();
+        }
     }
 
 public:
@@ -307,7 +317,7 @@ public:
         return _administration.Delete(this, _refCount);
     }
 
-    void Updated()
+    void Updated(const Exchange::IConnectionProperties::INotification::Source /* event */)
     {
         Callbacks::iterator index(_callbacks.begin());
 
@@ -340,48 +350,96 @@ public:
     bool IsAudioPassthrough() const
     {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->IsAudioPassthrough();
+        bool value = false;
+        return (_displayConnection != nullptr ? 
+                   ( _displayConnection->IsAudioPassthrough(value) == Core::ERROR_NONE ? value: false) :
+                   false );
     }
     bool Connected() const
     {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->Connected();
+        bool value = false;
+        return (_displayConnection != nullptr ? 
+                   ( _displayConnection->Connected(value) == Core::ERROR_NONE ? value : false) :
+                   false );
     }
     uint32_t Width() const
     {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->Width();
+        uint32_t value = 0;
+        return (_displayConnection != nullptr ? 
+                   ( _displayConnection->Width(value) == Core::ERROR_NONE ? value : 0) :
+                   0 );
     }
     uint32_t Height() const
     {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->Height();
+        uint32_t value = 0;
+        return (_displayConnection != nullptr ? 
+                   ( _displayConnection->Height(value) == Core::ERROR_NONE ? value : 0) :
+                   0 );
+    }
+    uint8_t WidthInCentimeters() const
+    {
+        ASSERT(_displayConnection != nullptr);
+        uint8_t value = 0;
+        return (_displayConnection != nullptr ?
+                   ( _displayConnection->WidthInCentimeters(value) == Core::ERROR_NONE ? value : 0) :
+                   0 );
+    }
+    uint8_t HeightInCentimeters() const
+    {
+        ASSERT(_displayConnection != nullptr);
+        uint8_t value = 0;
+        return (_displayConnection != nullptr ?
+                   ( _displayConnection->HeightInCentimeters(value) == Core::ERROR_NONE ? value : 0) :
+                   0 );
     }
     uint32_t VerticalFreq() const
     {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->VerticalFreq();
+        uint32_t value = 0;
+        return (_displayConnection != nullptr ? 
+                   ( _displayConnection->VerticalFreq(value) == Core::ERROR_NONE ? value : 0) :
+                   0 );
     }
     bool IsAtmosSupported() const
     {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->IsAtmosSupported();
+        bool value = false;
+        return (_displayConnection != nullptr ? 
+                   ( _displayConnection->IsAtmosSupported(value) == Core::ERROR_NONE ? value : false) :
+                   false );
     }
-    Exchange::IConnectionProperties::HDRType HDR() const
-    {
+
+    uint32_t EDID(uint16_t& len, uint8_t data[]) {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->Type();
+        return _displayConnection->EDID(len, data);
+    }
+
+    Exchange::IHDRProperties::HDRType HDR() const
+    {
+        Exchange::IHDRProperties::HDRType value = Exchange::IHDRProperties::HDRType::HDR_OFF;
+        return (_hdrProperties != nullptr ?
+                   ( _hdrProperties->HDRSetting(value) == Core::ERROR_NONE ? value :
+                     Exchange::IHDRProperties::HDRType::HDR_OFF ) :
+                     Exchange::IHDRProperties::HDRType::HDR_OFF );
     }
     Exchange::IConnectionProperties::HDCPProtectionType HDCPProtection() const
     {
         ASSERT(_displayConnection != nullptr);
-        return _displayConnection->HDCPProtection();
+        Exchange::IConnectionProperties::HDCPProtectionType value = Exchange::IConnectionProperties::HDCPProtectionType::HDCP_Unencrypted;
+        return (_displayConnection != nullptr ? 
+                   ( static_cast<const Exchange::IConnectionProperties*>(_displayConnection)->HDCPProtection(value) == Core::ERROR_NONE ? value : 
+                     Exchange::IConnectionProperties::HDCPProtectionType::HDCP_Unencrypted ) :
+                   Exchange::IConnectionProperties::HDCPProtectionType::HDCP_Unencrypted );
     }
 
 private:
     mutable int _refCount;
     const string _name;
     Exchange::IConnectionProperties* _displayConnection;
+    Exchange::IHDRProperties* _hdrProperties;
     Core::Sink<Notification> _notification;
     Callbacks _callbacks;
     static DisplayInfo::DisplayInfoAdministration _administration;
@@ -461,19 +519,19 @@ displayinfo_hdr_t displayinfo_hdr(struct displayinfo_type* displayinfo)
     displayinfo_hdr_t result = DISPLAYINFO_HDR_UNKNOWN;
 
     switch (reinterpret_cast<DisplayInfo*>(displayinfo)->HDR()) {
-    case Exchange::IConnectionProperties::HDR_OFF:
+    case Exchange::IHDRProperties::HDR_OFF:
         result = DISPLAYINFO_HDR_OFF;
         break;
-    case Exchange::IConnectionProperties::HDR_10:
+    case Exchange::IHDRProperties::HDR_10:
         result = DISPLAYINFO_HDR_10;
         break;
-    case Exchange::IConnectionProperties::HDR_10PLUS:
+    case Exchange::IHDRProperties::HDR_10PLUS:
         result = DISPLAYINFO_HDR_10PLUS;
         break;
-    case Exchange::IConnectionProperties::HDR_DOLBYVISION:
+    case Exchange::IHDRProperties::HDR_DOLBYVISION:
         result = DISPLAYINFO_HDR_DOLBYVISION;
         break;
-    case Exchange::IConnectionProperties::HDR_TECHNICOLOR:
+    case Exchange::IHDRProperties::HDR_TECHNICOLOR:
         result = DISPLAYINFO_HDR_TECHNICOLOR;
         break;
     default:
@@ -507,4 +565,19 @@ displayinfo_hdcp_protection_t displayinfo_hdcp_protection(struct displayinfo_typ
     return type;
 }
 
+uint32_t displayinfo_edid(struct displayinfo_type* displayinfo, uint8_t buffer[], uint16_t* length)
+{
+    return reinterpret_cast<DisplayInfo*>(displayinfo)->EDID(*length, buffer);
+}
+
+uint8_t displayinfo_width_in_centimeters(struct displayinfo_type* displayinfo)
+{
+    return reinterpret_cast<DisplayInfo*>(displayinfo)->WidthInCentimeters();
+}
+
+uint8_t displayinfo_height_in_centimeters(struct displayinfo_type* displayinfo)
+{
+    return reinterpret_cast<DisplayInfo*>(displayinfo)->HeightInCentimeters();
+}
+
 } // extern "C"
diff --git a/Source/displayinfo/include/displayinfo.h b/Source/displayinfo/include/displayinfo.h
index ecfc50d5..722bd036 100644
--- a/Source/displayinfo/include/displayinfo.h
+++ b/Source/displayinfo/include/displayinfo.h
@@ -206,6 +206,37 @@ EXTERNAL displayinfo_hdr_t displayinfo_hdr(struct displayinfo_type* instance);
  **/
 EXTERNAL displayinfo_hdcp_protection_t displayinfo_hdcp_protection(struct displayinfo_type* instance);
 
+/**
+ * \brief Returns EDID data of a connected display.
+ *
+ * \param instance Instance of \ref displayinfo_type.
+ * \param buffer Buffer that will contain the data.
+ * \param length Size of \ref buffer. On success it'll be set to the length of the actuall data in \ref buffer.
+ *
+ **/
+EXTERNAL uint32_t displayinfo_edid(struct displayinfo_type* instance, uint8_t buffer[], uint16_t* length);
+
+/**
+ * \brief Get the heigth of the connected display in centimaters
+ *
+ * \param instance Instance of \ref displayinfo_type.
+ *
+ * \return The current heigth in centimeters, 0 on error or invalid connection
+ *
+ **/
+EXTERNAL uint8_t displayinfo_width_in_centimeters(struct displayinfo_type* instance);
+
+/**
+ * \brief Get the width of the connected display in centimeters
+ *
+ * \param instance Instance of \ref displayinfo_type.
+ *
+ * \return The current width in centimeters, 0 on error or invalid connection
+ *
+ **/
+EXTERNAL uint8_t displayinfo_height_in_centimeters(struct displayinfo_type* instance);
+
+
 #ifdef __cplusplus
 } // extern "C"
 #endif
diff --git a/Source/interfaces/CMakeLists.txt b/Source/interfaces/CMakeLists.txt
index b61d5129..72dba491 100644
--- a/Source/interfaces/CMakeLists.txt
+++ b/Source/interfaces/CMakeLists.txt
@@ -25,21 +25,22 @@ file(GLOB JSON_FILE "${CMAKE_CURRENT_SOURCE_DIR}/json/*.json")
 list(APPEND PUBLIC_HEADERS Module.h)
 list(APPEND PUBLIC_HEADERS definitions.h)
 
-ProxyStubGenerator(INPUT "${CMAKE_CURRENT_SOURCE_DIR}" OUTDIR "${CMAKE_CURRENT_BINARY_DIR}/generated/proxystubs")
-JsonGenerator(CODE INPUT ${JSON_FILE} OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/generated/json")
-JsonGenerator(CODE INPUT "${CMAKE_CURRENT_SOURCE_DIR}/I*.h" OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/generated/json")
+ProxyStubGenerator(INPUT "${CMAKE_CURRENT_SOURCE_DIR}" OUTDIR "${CMAKE_CURRENT_BINARY_DIR}/generated/proxystubs" INCLUDE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/..)
+JsonGenerator(CODE INPUT ${JSON_FILE} OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/generated/json" INCLUDE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/..)
+JsonGenerator(CODE INPUT "${CMAKE_CURRENT_SOURCE_DIR}/I*.h" OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/generated/json" INCLUDE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/..)
 
 file(GLOB PROXY_STUB_SOURCES "${CMAKE_CURRENT_BINARY_DIR}/generated/proxystubs/ProxyStubs*.cpp")
-add_library(${TargetMarshalling} SHARED ${PROXY_STUB_SOURCES})
+add_library(${TargetMarshalling} SHARED 
+        Module.cpp
+        ${PROXY_STUB_SOURCES}
+        )
 
 target_include_directories(${TargetMarshalling} PRIVATE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>)
 
-file(GLOB JSON_DATA_HEADERS "${CMAKE_CURRENT_BINARY_DIR}/generated/json/JsonData*.h")
 file(GLOB JSON_ENUM_SOURCES "${CMAKE_CURRENT_BINARY_DIR}/generated/json/JsonEnum*.cpp")
 file(GLOB JSON_LINK_HEADERS "${CMAKE_CURRENT_BINARY_DIR}/generated/json/J*.h")
 
 add_library(${TargetDefinitions} SHARED
-        Module.cpp
         Definitions.cpp
         ${JSON_ENUM_SOURCES}
         )
@@ -51,6 +52,10 @@ target_link_libraries(${TargetMarshalling}
           CompileSettingsDebug::CompileSettingsDebug
         )
 
+target_compile_definitions(${TargetMarshalling}
+        PUBLIC
+            PROXYSTUB_BUILDING=1)
+
 target_link_libraries(${TargetDefinitions}
         PUBLIC
           ${NAMESPACE}Core::${NAMESPACE}Core
@@ -94,6 +99,7 @@ target_include_directories(${TargetDefinitions}
           $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
           $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/../>
           $<INSTALL_INTERFACE:include/${NAMESPACE}>
+          $<INSTALL_INTERFACE:include/${NAMESPACE}/interfaces>
         )
 
 install(
@@ -111,14 +117,9 @@ install(
         LIBRARY DESTINATION lib/${NAMESPACE_LIB}/proxystubs COMPONENT libs      # shared lib
 )
 
-install(
-        FILES ${JSON_DATA_HEADERS}
-        DESTINATION include/${NAMESPACE}/interfaces/json
-)
-
 install(
         FILES ${JSON_LINK_HEADERS}
-        DESTINATION include/${NAMESPACE}/interfaces
+        DESTINATION include/${NAMESPACE}/interfaces/json
 )
 
 InstallPackageConfig(
diff --git a/Source/interfaces/IAVSClient.h b/Source/interfaces/IAVSClient.h
index a950d96d..f55f4fa1 100644
--- a/Source/interfaces/IAVSClient.h
+++ b/Source/interfaces/IAVSClient.h
@@ -52,7 +52,7 @@ namespace Exchange {
         /// @brief Mutes the audio output of AVS
         /// @param mute Mute or umute (e.g. true)
         /// @retval ERROR_GENERAL when there is a fatal error or authorisation is not possible
-        virtual uint32_t Mute(const bool mute) = 0;
+        virtual uint32_t Mute(const bool muted) = 0;
 
         /// @brief Starts or stops the voice recording, skipping keyword detection
         /// @param start Start or stop voice recording (e.g. true)
diff --git a/Source/interfaces/IDisplayInfo.h b/Source/interfaces/IDisplayInfo.h
index 4484d5f1..5674212c 100644
--- a/Source/interfaces/IDisplayInfo.h
+++ b/Source/interfaces/IDisplayInfo.h
@@ -18,60 +18,135 @@
  */
 
 #pragma once
-
 #include "Module.h"
 
+// @stubgen:include <com/IRPCIterator.h>
+
 namespace WPEFramework {
 namespace Exchange {
 
-    struct IGraphicsProperties : virtual public Core::IUnknown {
+    /* @json */
+    struct EXTERNAL IGraphicsProperties : virtual public Core::IUnknown {
         enum { ID = ID_GRAPHICS_PROPERTIES };
 
-        virtual ~IGraphicsProperties() {}
+        // @property
+        // @brief Total GPU DRAM memory (in bytes)
+        // @return total: Total GPU RAM
+        virtual uint32_t TotalGpuRam(uint64_t& total /* @out */) const = 0;
 
-        virtual uint64_t TotalGpuRam() const = 0;
-        virtual uint64_t FreeGpuRam() const = 0;
+        // @property
+        // @brief Free GPU DRAM memory (in bytes)
+        // @return free: Free GPU RAM
+        virtual uint32_t FreeGpuRam(uint64_t& free /* @out */) const = 0;
     };
 
-    struct IConnectionProperties : virtual public Core::IUnknown {
+    /* @json */
+    struct EXTERNAL IConnectionProperties : virtual public Core::IUnknown {
         enum { ID = ID_CONNECTION_PROPERTIES };
 
-        virtual ~IConnectionProperties() { }
-
-        enum HDRType : uint8_t {
-            HDR_OFF,
-            HDR_10,
-            HDR_10PLUS,
-            HDR_HLG,
-            HDR_DOLBYVISION,
-            HDR_TECHNICOLOR
-        };
-
         enum HDCPProtectionType : uint8_t {
             HDCP_Unencrypted,
             HDCP_1X,
             HDCP_2X
         };
 
-        struct INotification : virtual public Core::IUnknown {
+        /* @event */
+        struct EXTERNAL INotification : virtual public Core::IUnknown {
             enum { ID = ID_CONNECTION_PROPERTIES_NOTIFICATION };
 
-            virtual ~INotification() {}
+            enum Source : uint8_t {
+                PRE_RESOLUTION_CHANGE,
+                POST_RESOLUTION_CHANGE,
+                HDMI_CHANGE,
+                HDCP_CHANGE,
+            };
 
-            virtual void Updated() = 0;
+            virtual void Updated(const Source event) = 0;
         };
 
         virtual uint32_t Register(INotification*) = 0;
         virtual uint32_t Unregister(INotification*) = 0;
 
-        virtual bool IsAudioPassthrough () const = 0;
-        virtual bool Connected() const = 0;
-        virtual uint32_t Width() const = 0;
-        virtual uint32_t Height() const = 0;
-        virtual uint32_t VerticalFreq() const = 0;
-        virtual HDRType Type() const = 0;
-        virtual bool IsAtmosSupported() const = 0;
-        virtual HDCPProtectionType HDCPProtection() const = 0;
+        virtual uint32_t IsAtmosSupported(bool& supported /* @out */) const = 0;
+
+        // @property
+        // @brief Current audio passthrough status on HDMI
+        // @param passthru: enabled/disabled
+        virtual uint32_t IsAudioPassthrough (bool& passthru /* @out */) const = 0;
+
+        // @property
+        // @brief Current HDMI connection status
+        // @param isconnected: connected/disconnected
+        virtual uint32_t Connected(bool& isconnected /* @out */) const = 0;
+
+        // @property
+        // @brief Horizontal resolution of TV
+        // @param width:  width of TV in pixels
+        virtual uint32_t Width(uint32_t& width /* @out */) const = 0;
+
+        // @property
+        // @brief Vertical resolution of TV
+        // @param height:  height of TV in pixels
+        virtual uint32_t Height(uint32_t& height /* @out */) const = 0;
+
+        // @property
+        // @brief Vertical Frequency
+        // @param vf: vertical freq
+        virtual uint32_t VerticalFreq(uint32_t& vf /* @out */) const = 0;
+
+        // @brief TV's Extended Display Identification Data
+        // @param edid: edid byte string
+        virtual uint32_t EDID (uint16_t& length /* @inout */, uint8_t data[] /* @out @length:length */) const = 0;
+
+        // @brief Horizontal size in centimeters
+        // @param width: width in cm
+        virtual uint32_t WidthInCentimeters(uint8_t& width /* @out */) const = 0;
+
+        // @brief Vertical size in centimeters
+        // @param width: height in cm
+        virtual uint32_t HeightInCentimeters(uint8_t& heigth /* @out */) const = 0;
+
+        // @property
+        // @brief HDCP protocol used for transmission
+        // @param value: protocol
+        virtual uint32_t HDCPProtection (HDCPProtectionType& value /* @out */) const = 0;
+        virtual uint32_t HDCPProtection (const HDCPProtectionType value) = 0;
+
+        // @property
+        // @brief Video output port on the STB used for connection to TV
+        // @param name: video output port name
+        virtual uint32_t PortName (string& name /* @out */) const = 0;
+    };
+
+    /* @json */
+    struct EXTERNAL IHDRProperties : virtual public Core::IUnknown {
+        enum { ID = ID_HDR_PROPERTIES };
+
+        enum HDRType : uint8_t {
+            HDR_OFF,
+            HDR_10,
+            HDR_10PLUS,
+            HDR_HLG,
+            HDR_DOLBYVISION,
+            HDR_TECHNICOLOR
+        };
+
+        typedef RPC::IIteratorType<HDRType, ID_HDR_ITERATOR> IHDRIterator;
+
+        // @property
+        // @brief HDR formats supported by TV
+        // @return HDRType: array of HDR formats
+        virtual uint32_t TVCapabilities(IHDRIterator*& type /* @out */) const = 0;
+
+        // @property
+        // @brief HDR formats supported by STB
+        // @return HDRType: array of HDR formats
+        virtual uint32_t STBCapabilities(IHDRIterator*& type /* @out */) const = 0;
+
+        // @property
+        // @brief HDR format in use
+        // @param type: HDR format
+        virtual uint32_t HDRSetting(HDRType& type /* @out */) const = 0;
     };
 }
 }
diff --git a/Source/interfaces/Ids.h b/Source/interfaces/Ids.h
index e35c995e..524a211b 100644
--- a/Source/interfaces/Ids.h
+++ b/Source/interfaces/Ids.h
@@ -152,6 +152,9 @@ namespace Exchange {
         ID_CONNECTION_PROPERTIES,
         ID_CONNECTION_PROPERTIES_NOTIFICATION,
 
+        ID_HDR_PROPERTIES,
+        ID_HDR_ITERATOR,
+
         ID_PLAYER_PROPERTIES,
         ID_PLAYER_PROPERTIES_AUDIO,
         ID_PLAYER_PROPERTIES_VIDEO,
